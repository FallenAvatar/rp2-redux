buildscript {
    repositories {
        maven { url = 'https://files.minecraftforge.net/maven' }
        mavenCentral()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '4.1.+', changing: true
    }
}

if (hasProperty('buildScan')) {
    buildScan {
        termsOfServiceUrl = 'https://gradle.com/terms-of-service'
        termsOfServiceAgree = 'yes'
    }
}

def projects = [
	"CoFHCore",
	"ThermalCore",
	"RP2"
]



configure(subprojects.findAll { projects.contains(it.name) }) {
	println 'test'
	println name
	
	// We need to base plugin for artifacts support.
	apply plugin: 'base'
	apply plugin: 'net.minecraftforge.gradle'
	apply plugin: 'eclipse'
	apply plugin: 'maven-publish'

	sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8'

	// Include resources generated by data generators.
	sourceSets.main.resources { srcDir 'src/generated/resources' }

	// Archive task where the archive file
	// is the artifact for our project we want
	// to use in aonther project.

	configurations {
		// New configuration to associate
		// dist task output with.
		conf
	}

	artifacts {
		// Declare output of build task
		// as artifact for the conf
		// configuration.
		conf build
	}
}

// Project with dependencies on the artifacts
// of projectA and projectB.
project(":") {

	configurations {
		// Configuration needed to use
		// in the dependencies.
		conf {
			abcd 'test'
		}
	}

	dependencies {
		// Define that we depend on the artifacts
		// of projectA and projectB assigned to the
		// dockerDist configuration.
		projects.each { p ->
			implementation project(path: ":$p", configuration: 'conf')
		}
	}

	task build(type: Copy) {
		into "build/libs"

		// Use the artifacts from the other projects.
		// Gradle knows that tasks that created the artifacts
		// and will invoke them for us.
		from configurations.conf
	}

	conf {
		abcd 'test'
	}
}